---
title: "Presentation Exercise"
---

## Get the original data 
I found this data set from the FiveThirtyEight website about American opinions on the Coronavirus in relation to political events from March 2020 to April 2021: https://data.fivethirtyeight.com/ I chose to use the `covid_concern_polls.csv` file to recreate the graph about how worried Americans are about Covid infection. I examined the data to discover there are start and end dates for each response and four levels of worry for each topic: very, somewhat, not very, and not at all, which are all represented on the graph I want to replicate. There are 678 observations of 15 variables stored in this dataset. 
```{r}
library(readr)
library(here)
pollsdata <- read_csv(here("presentation-exercise", "covid_concern_polls.csv"))
str(pollsdata)
dim(pollsdata)
```

## Ask AI to recreate the original graph
This is the original prompt that I asked ChatGPT 3.5: R code to generate the graph titled "How worried are Americans about infection?" on this website https://projects.fivethirtyeight.com/coronavirus-polls/ using the covid_concern_polls.csv file from this github repository https://github.com/fivethirtyeight/covid-19-polls

I used the links to the website and GitHub repository to ensure that it knew which graph I am trying to recreate, which has been saved as `Inspiration_graph.png` in the `presentation-exercise` folder. The first step it gave me was to load three packages: readr, dplyr, and ggplot2. The second step was to save the data as an object, which I have already done. Next, it suggested filtering the data for the question regarding infection: "How worried are you about personally being infected with coronavirus?". I made several modifications to the code because it did not know the object name that I stored my data in, and it did not know the exact verbiage of the question that was asked. This was not successful because I do not have one "estimate" for the percentage of people in each of the worry categories ranging from `not_at_all` to `very`. I should have known that this code would not be accurate because it said these steps will produce a polar bar graph when I am trying to produce a line graph. I commented out this code for the sake of rendering my website with this exercise.  
```{r}
# load required packages
library(dplyr)
library(ggplot2)

# modified filtering code
# concern_data <- pollsdata %>%
 # filter(text == "How worried are you about you or someone in your family being infected with the Coronavirus??") %>%
 # select(starts_with("estimate"))
```

This is the second prompt I asked ChatGPT: R code to produce a line graph with percentages of four different categories "very", "somewhat", "not very",  and "not at all" on the y-axis and time on the x-axis using the covid_concern_polls.csv file from this github repository https://github.com/fivethirtyeight/covid-19-polls 

I asked for a line graph specifically, and I know that I need to create variables with the percentages of each response category. I filtered for the question of interest and found there were only 2 observations with a response to this question. The graph models how concerned Americans are that they, someone in their family or someone else they know will be infected with Coronavirus, so I filtered for responses to all of the questions asking about "concern" over Coronavirus infections, which yielded 77 observations.
```{r}
# filter for all responses about Coronavirus concern
concern_data <- pollsdata %>%
  filter(text == "How worried are you about you or someone in your family being infected with the Coronavirus?" | text == "Are you concerned, or not concerned about yourself personally or a close family member getting the coronavirus?" | text == "How concerned are you personally about catching coronavirus?" | text == "How concerned are you that someone you care about will get the coronavirus?" | text == "How concerned are you that you could catch the COVID-19 virus?" | text == "How concerned are you that you or someone in your family will contract the coronavirus?" | text == "How concerned are you that you or someone in your family will get sick from the coronavirus: very concerned, somewhat concerned, not too concerned, or not concerned at all?" | text == "How concerned are you that you or someone you know will be infected with the coronavirus?" | text == "How concerned are you that you, personally, will get the coronavirus?" | text == "How concerned, if at all, do you currently feel about the following: - Family members getting coronavirus" | text == "How concerned, if at all, do you currently feel about the following: - Getting coronavirus yourself" | text == "How personally concerned are you about the chances of you or someone in your family becoming infected with the coronavirus?")
```

The next suggestion from ChatGPT was to create percentages for each of the response variables. The first variable that had to be changed here is the grouping factor because `modeldate` was not included in the original dataset. Additionally, there were no "estimate" variables, so I just used the column names instead because each column had count data for that observation. 
```{r}
# group data by date and calculate percentages for each category
concern_data2 <- concern_data %>%
  group_by(end_date) %>%
  summarise(
    very_percent = sum(very) / n(),
    somewhat_percent = sum(somewhat) / n(),
    not_very_percent = sum(not_very) / n(),
    not_at_all_percent = sum(not_at_all) / n()
  )

# check that it worked 
str(concern_data2)
```
ChatGPT suggested changing the shape of the data before attempting to visualize it. It did not account for the fact that I need the `tidyr` package to use the pivot_longer() function, so I loaded that package here. This transformation left me with a data set with 276 observations of 3 variables.
```{r}
# load packages
library(tidyr)

# convert shape of the dataset
concern_data_long <- concern_data2 %>%
  pivot_longer(cols = c(very_percent, somewhat_percent, not_very_percent, not_at_all_percent),
               names_to = "Concern Level",
               values_to = "Percentage")
```

Lastly, I attempted to recreate the plot from the original webpage. The first attempt is not bad, but it looks like I have missing data in the "not_at_all_percent" variable which was not the case in the graph on the website. 
```{r}
# attempt to recreate the original plot
graph1 <- ggplot(concern_data_long, aes(x = end_date, y = Percentage, color = `Concern Level`)) +
  geom_line() +
  labs(title = "COVID-19 Concern Levels Over Time",
       x = "Date",
       y = "Percentage",
       color = "Concern Level") +
  theme_minimal()
graph1
```

After finding there are 6 missing observations of the `Percentage` variable, I decided to omit those values because they account for such a minimal percentage of total observations, which fixed the strange gap in the line graph. 
```{r}
# explore for missing data and remove it
sum(is.na(concern_data_long$Percentage))
concern_data_long <- na.omit(concern_data_long)

# check that missing data removal fixed the issue
graph2 <- ggplot(concern_data_long, aes(x = end_date, y = Percentage, color = `Concern Level`)) +
  geom_line() +
  labs(title = "COVID-19 Concern Levels Over Time",
       x = "Date",
       y = "Percentage",
       color = "Concern Level") +
  theme_minimal()
graph2
```
I need to make aesthetic changes, so the replicated graph matches the original graph more accurately. The title needs to be changed and centered. I used ChatGPT to create code to separate the title into three lines and change the size of the second title line, so it will fit better. I got a warning message that vectorized input to element_text is not supported in ggplot2, so all three lines of the title are the same size. The original x-axis labels each month, so I created custom labels and dropped the "date" label for the entire axis. While the original graph is interactive, that is slightly out of reach with my coding knowledge right now, so I decided to keep the stagnant legend. I noticed the legend was inverted, so I corrected that. I manually changed the colors of the lines using hex codes.  
```{r}
# create 14 breaks for the x-axis and custom labels for each break
breaks <- seq(as.Date("2020-02-28"), by = "month", length.out = 14)
custom_labels <- c("3/1/20", "4/1", "5/1", "6/1", "7/1",
                   "8/1", "9/1", "10/1", "11/1", "12/1", "1/1/21", "2/1", "3/1", "4/1")

# create updated version of the graph with modificationss
graph3 <- ggplot(concern_data_long, aes(x = end_date, y = Percentage, color = `Concern Level`)) +
    geom_line() +
    scale_color_manual(values = c("#800080","#BA55D3","#FFDAB9","#FF0000")) +
    labs(title = paste("How worried are Americans about infection?", "\n", "How concerned Americans say that they, someone in their family or someone else they know will", "\n", "become infected with the coronavirus")) +
    theme(plot.title = element_text(hjust = 0.5,
                                    size = 8)) +
    scale_x_date(breaks = breaks, labels = custom_labels) +
    xlab(NULL) + 
    guides(color = guide_legend(reverse = TRUE))
graph3

```

Lastly, I need to add labels on specific dates. I used this simple prompt in ChatGPT: how to add labels to specific dates on a line graph. It suggested adding a geom_text() layer. I had to go back and forth with ChatGPT a couple times to find a date format that worked. Unfortunately, I received a consistent  error about the geom_text() layer not being able to find the `Percentage` variable which prevented it from adding the labels onto my existing graph. I attempted the same format with geom_label() and got the same error. I added an arbitrary `Percentage` variable to the labels_data just to see if that would fix the error, but it was also unsuccessful. I would appreciate any input on how to solve this error. I commented out the last piece of code for the sake of rendering my website. 
```{r}
# create custom labels to be added as another layer on the original graph 
labels_data <- data.frame(
  modeldate = as.Date(c("2020-02-29", "2020-05-28", "2020-10-02", "2020-11-07", "2021-01-02")),  
  label_text = c("First US death reported", "US deaths surpass 100,000", "Trump diagnosed with Covid-19", "Biden declared election winner", "Biden sworn into office",
  Percentage = c(60, 60, 60, 60, 60))
)

 ## graph4 <- graph3 + 
 ##  geom_label(data = labels_data, aes(x = modeldate, y=Percentage, label = label_text))

```

Since Dr. Handel recommended that new users begin with the `gt` package when creating tables, I specifically asked ChatGPT to use that package with this prompt: R code using the gt package to create a table displaying the percentages for four categories (very,  somewhat, not very, not at all) for each daily observation. I am using the same data from the exercise above, which is stored as `concern_data2`.

The original code provided by ChatGPT had outdated syntax in the column argument of the tab_spanner() function, so I updated that using the simple c() function. I also had to add the real variable names found in `concern_data2`. 

```{r}
# load packages
library(gt)

# generate publication quality table
table1 <- concern_data2 %>%
  gt() %>%
  tab_spanner(
    label = "Percentage",
    columns = c(very_percent, somewhat_percent, not_very_percent, not_at_all_percent)
  ) %>%
  tab_header(
    title = "Observations with Percentage Breakdown"
  )
table1
```

The first table looks decent, but I want to clean up a few things. I added a more descriptive title and renamed the columns, so the table would not contain variable names. I felt like it was unnecessary to have 5 decimal points for each percentage, so I limited the decimals to 1 place using the fmt_number() function. The result is a clean and publication-quality table.
```{r}
table2 <- concern_data2 %>%
  rename("Date" = end_date,
        "Very" = very_percent,
        "Somewhat" = somewhat_percent,
        "Not Very" = not_very_percent,
        "Not at all" = not_at_all_percent) %>%
  gt() %>%
  tab_spanner(label = "Percentage",
              columns = c("Very", "Somewhat", "Not Very", "Not at all")) %>%
  tab_header(title = "Levels of concern about COVID-19 infections among Americans") %>% 
  fmt_number(columns = c("Very", "Somewhat", "Not Very", "Not at all"),
             decimals = 1)
table2
```
